package com.nexxmobile.inapptutorial;
//TODO don't forget to refactor your package name 
import java.util.List;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.ConnectivityManager;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;

import com.nexxmobile.inapptutorial.utils.IabHelper;
import com.nexxmobile.inapptutorial.utils.IabResult;
import com.nexxmobile.inapptutorial.utils.Inventory;
import com.nexxmobile.inapptutorial.utils.Purchase;
import com.unity3d.player.UnityPlayer;
import com.unity3d.player.UnityPlayerActivity;

public class GameActivity extends UnityPlayerActivity {
	String TAG = "Unity";
	private Activity _activity;

	private int _coinNumber = 5;

	// (arbitrary) request code for the purchase flow
	static final int RC_REQUEST = 10001;
	
	// TODO SET YOUR OWN SKU DATA 
	// SKUs for our products: (consumable)
	// ids must be unique, if you have used it before you cannot use it again!
	static final String SKU_COIN_10 = "com.nexxmobile.inapptutorial_10_coin";
	static final String SKU_COIN_70 = "com.nexxmobile.inapptutorial_70_coin";
	static final String SKU_COIN_130 = "com.nexxmobile.inapptutorial_130_coin";
	static final String SKU_COIN_190 = "com.nexxmobile.inapptutorial_190_coin";
	static final String SKU_COIN_250 = "com.nexxmobile.inapptutorial_250_coin";
	
	// The helper object
	IabHelper mHelper;

	@Override
	protected void onCreate(Bundle arg0) {
		
		super.onCreate(arg0);
		_activity = UnityPlayer.currentActivity;

		// load saved coin data
		loadData();

		// TODO CHANGE KEY, don't forget to sign your application with your production key while building .apk!
		String base64EncodedPublicKey = "YOUR PUBLIC KEY GENERATED BY GOOGLE PLAY. YOU CAN GET IT BY UPLOADING YOUR FIRST APK TO DEVELOPER CONSOLE";
		// Create the helper, passing it our context and the public key to
		// verify signatures with
		Log.d("Unity", "Creating IAB helper.");
		mHelper = new IabHelper(this, base64EncodedPublicKey);

		// enable debug logging (for a production application, you should set
		// this to false).
		mHelper.enableDebugLogging(true);

		// Start setup. This is asynchronous and the specified listener
		// will be called once setup completes.
		Log.d("Unity", "Starting setup.");
		mHelper.startSetup(new IabHelper.OnIabSetupFinishedListener() {
			public void onIabSetupFinished(IabResult result) {
				Log.d("Unity", "Setup finished.");

				if (!result.isSuccess()) {
					// Oh no, there was a problem.
					alert("Opps, something went wrong");
					return;
				}

				// Have we been disposed of in the meantime? If so, quit.
				if (mHelper == null)
					return;

				// IAB is fully set up. Now, let's get an inventory of stuff we
				// own.
				Log.d("Unity", "Setup successful. Querying inventory.");
				mHelper.queryInventoryAsync(mGotInventoryListener);
				
			}
		});
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		Log.d(TAG, "onActivityResult(" + requestCode + "," + resultCode + ","
				+ data);
		if (mHelper == null)
			return;

		// Pass on the activity result to the helper for handling
		if (!mHelper.handleActivityResult(requestCode, resultCode, data)) {
			// not handled, so handle it ourselves (here's where you'd
			// perform any handling of activity results not related to in-app
			// billing...
			super.onActivityResult(requestCode, resultCode, data);
		} else {
			Log.d(TAG, "onActivityResult handled by IABUtil.");
		}
	}

	@Override
	public void onDestroy() {
		super.onDestroy();

		// very important:
		Log.d(TAG, "Destroying helper.");
		if (mHelper != null) {
			mHelper.dispose();
			mHelper = null;
		}
	}

	// Listener that's called when we finish querying the items and
	// subscriptions we own
	IabHelper.QueryInventoryFinishedListener mGotInventoryListener = new IabHelper.QueryInventoryFinishedListener() {
		public void onQueryInventoryFinished(IabResult result,
				Inventory inventory) {
			Log.d(TAG, "Query inventory finished.");

			// Have we been disposed of in the meantime? If so, quit.
			if (mHelper == null)
				return;

			// Is it a failure?
			if (result.isFailure()) {
				// alert("Failed to query inventory: " + result);
				return;
			}

			Log.d(TAG, "Query inventory was successful.");

			// Purchase tips_5 = inventory.getPurchase(SKU_TIP_5);
			// mHelper.consumeAsync(tips_5, mConsumeFinishedListener);
			// Log.d(TAG,
			// "Initial inventory query finished; enabling main UI.");
		}
	};

	
	/** PUBLICS */
	public void shareOnFacebook() {
		if (checkConnection()) {
			try {
				_activity.getPackageManager().getPackageInfo(
						"com.facebook.katana", 0);
				startActivity(new Intent(Intent.ACTION_VIEW,
						Uri.parse("fb://page/" + Constants.FB_PAGE_ID)));
			} catch (Exception e) {
				startActivity(new Intent(Intent.ACTION_VIEW,
						Uri.parse("https://www.facebook.com/"
								+ Constants.FB_PAGE_ID)));
			}
		}
	}

	public void shareOnTwitter() {
		if (checkConnection()) {
			Intent shareIntent = new Intent(Intent.ACTION_SEND);
			shareIntent.setType("text/plain");
			String shareText = Constants.SHARE_TEXT;
			shareIntent.putExtra(Intent.EXTRA_TEXT, shareText);
			String appName = "twitter";
			final PackageManager pm = _activity.getPackageManager();
			final List<?> activityList = pm.queryIntentActivities(shareIntent,
					0);
			int len = activityList.size();
			for (int i = 0; i < len; i++) {
				final ResolveInfo app = (ResolveInfo) activityList.get(i);
				if ((app.activityInfo.name.contains(appName))) {
					final ActivityInfo activity = app.activityInfo;
					final ComponentName name = new ComponentName(
							activity.applicationInfo.packageName, activity.name);
					shareIntent.setComponent(name);
					_activity.startActivity(shareIntent);
					return;
				}
			}
			startActivity(new Intent(Intent.ACTION_VIEW,
					Uri.parse("https://www.twitter.com/" + "nexxmobile")));
		}
	}


	public void buyCoins(int num) {
		Log.d(TAG, "Launching purchase flow for " + num + " items");
		String payload = "";

		switch (num) {
		case 10:
			mHelper.launchPurchaseFlow(this, SKU_COIN_10, RC_REQUEST,
					mPurchaseFinishedListener, payload);
			break;
		case 70:
			mHelper.launchPurchaseFlow(this, SKU_COIN_70, RC_REQUEST,
					mPurchaseFinishedListener, payload);
			break;
		case 130:
			mHelper.launchPurchaseFlow(this, SKU_COIN_130, RC_REQUEST,
					mPurchaseFinishedListener, payload);
			break;
		case 190:
			mHelper.launchPurchaseFlow(this, SKU_COIN_190, RC_REQUEST,
					mPurchaseFinishedListener, payload);
			break;
		case 250:
			mHelper.launchPurchaseFlow(this, SKU_COIN_250, RC_REQUEST,
					mPurchaseFinishedListener, payload);
			break;
		

		default:
			break;
		}
	}

	
	public int getCoinData()
	{
		return _coinNumber;
	}

	public void restore() {

	}
	
	

	/** Verifies the developer payload of a purchase. */
	boolean verifyDeveloperPayload(Purchase p) {
		// String payload = p.getDeveloperPayload();

		/*
		 * TODO: verify that the developer payload of the purchase is correct.
		 * It will be the same one that you sent when initiating the purchase.
		 * 
		 * WARNING: Locally generating a random string when starting a purchase
		 * and verifying it here might seem like a good approach, but this will
		 * fail in the case where the user purchases an item on one device and
		 * then uses your app on a different device, because on the other device
		 * you will not have access to the random string you originally
		 * generated.
		 * 
		 * So a good developer payload has these characteristics:
		 * 
		 * 1. If two different users purchase an item, the payload is different
		 * between them, so that one user's purchase can't be replayed to
		 * another user.
		 * 
		 * 2. The payload must be such that you can verify it even when the app
		 * wasn't the one who initiated the purchase flow (so that items
		 * purchased by the user on one device work on other devices owned by
		 * the user).
		 * 
		 * Using your own server to store and verify developer payloads across
		 * app installations is recommended.
		 */

		return true;
	}

	// Callback for when a purchase is finished
	IabHelper.OnIabPurchaseFinishedListener mPurchaseFinishedListener = new IabHelper.OnIabPurchaseFinishedListener() {
		public void onIabPurchaseFinished(IabResult result, Purchase purchase) {
			Log.d(TAG, "Purchase finished: " + result + ", purchase: "
					+ purchase);

			// if we were disposed of in the meantime, quit.
			if (mHelper == null)
				return;

			if (result.isFailure()) {
				alert("Opps, something went wrong.");
				return;
			}
			if (!verifyDeveloperPayload(purchase)) {
				alert("Error purchasing. Authenticity verification failed.");
				return;
			}

			Log.d(TAG, "Purchase successful.");

			if (purchase.getSku().equals(SKU_COIN_10)) {
				Log.d(TAG, "PurchaseD 5");
				_coinNumber += 10;
			} else if (purchase.getSku().equals(SKU_COIN_70)) {
				Log.d(TAG, "PurchaseD 10");
				_coinNumber += 70;
			} else if (purchase.getSku().equals(SKU_COIN_130)) {
				Log.d(TAG, "PurchaseD 15");
				_coinNumber += 130;
			} else if (purchase.getSku().equals(SKU_COIN_190)) {
				Log.d(TAG, "PurchaseD 20");
				_coinNumber += 190;
			} else if (purchase.getSku().equals(SKU_COIN_250)) {
				Log.d(TAG, "PurchaseD 25");
				_coinNumber += 250;
			} 
			// consume it so we can buy again
			mHelper.consumeAsync(purchase, mConsumeFinishedListener);
			saveData(_coinNumber);
		}

	};

	IabHelper.OnConsumeFinishedListener mConsumeFinishedListener = new IabHelper.OnConsumeFinishedListener() {
		public void onConsumeFinished(Purchase purchase, IabResult result) {
			Log.d(TAG, "Consumption finished. Purchase: " + purchase
					+ ", result: " + result);

			// if we were disposed of in the meantime, quit.
			if (mHelper == null)
				return;

			// We know this is the "gas" sku because it's the only one we
			// consume,
			// so we don't check which sku was consumed. If you have more than
			// one
			// sku, you probably should check...
			if (result.isSuccess()) {
				// successfully consumed, so we apply the effects of the item in
				// our
				// game world's logic, which in our case means filling the gas
				// tank a bit
				Log.d(TAG, "Consumption successful. Provisioning.");
			} else {
				// complain("Error while consuming: " + result);
			}
			Log.d(TAG, "End consumption flow.");
		}
	};

	private Boolean checkConnection() {
		ConnectivityManager cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
		if (cm.getActiveNetworkInfo() != null) {
			return true;
		}
		return false;
	}

	void saveData(int number) {
		SharedPreferences.Editor spe = getPreferences(MODE_PRIVATE).edit();
		spe.putInt("COIN", number);
		spe.commit();
	}

	
	void loadData() {
		SharedPreferences sp = getPreferences(MODE_PRIVATE);
		_coinNumber = sp.getInt("COIN", 5);
	}

	void alert(final String message) {
		runOnUiThread(new Runnable() {

			@Override
			public void run() {
				AlertDialog.Builder bld = new AlertDialog.Builder(_activity);
				bld.setMessage(message);
				bld.setNeutralButton("OK", new OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						// UnityPlayer
						// .UnitySendMessage(
						// Constants.NATIVE_LISTENER_NAME, "test",
						// "Test");
					}
				});
				bld.create().show();
			}
		});
	}

}
